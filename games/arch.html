<!DOCTYPE html>
<html lang="zh-Hant">
<head>
  <meta charset="UTF-8" />
  <title>弓箭手射擊遊戲</title>
  <style>
    body {
      text-align: center;
      font-family: Arial, sans-serif;
      margin-top: 20px;
      background: #eef2f3;
    }
    canvas {
      background: #a0d8f7;
      border: 2px solid #333;
      display: block;
      margin: 10px auto;
    }
    #startBtn, #restartBtn {
      padding: 10px 20px;
      font-size: 18px;
      cursor: pointer;
      border-radius: 5px;
      border: none;
      background: #4caf50;
      color: white;
      margin-top: 10px;
    }
    #restartBtn {
      background: #f44336;
    }
    #info {
      font-size: 20px;
      margin: 10px;
    }
  </style>
</head>
<body>
  <h1>弓箭手射擊遊戲</h1>
  <canvas id="gameCanvas" width="800" height="400"></canvas>
  <div id="info">時間: 60 秒｜分數: 0</div>
  <button id="startBtn">開始遊戲</button>
  <button id="restartBtn" style="display:none;">重新開始</button>

  <script>
    const canvas = document.getElementById('gameCanvas');
    const ctx = canvas.getContext('2d');
    const startBtn = document.getElementById('startBtn');
    const restartBtn = document.getElementById('restartBtn');
    const info = document.getElementById('info');
    const WIDTH = canvas.width;
    const HEIGHT = canvas.height;

    let gameRunning = false;
    let score = 0;
    let timeLeft = 60; // 秒
    let timerId;

    const archerX = 50;
    const archerY = HEIGHT - 100;

    const gravity = 0.5;
    let arrow = null;
    let enemy = null;

    let mouseX = archerX + 100;
    let mouseY = archerY;

    const maxPullDistance = 70;

    canvas.addEventListener('mousemove', (e) => {
      if(!gameRunning) return;
      const rect = canvas.getBoundingClientRect();
      mouseX = e.clientX - rect.left;
      mouseY = e.clientY - rect.top;
    });

    canvas.addEventListener('click', () => {
      if(!gameRunning) return;
      if(arrow === null){
        shootArrow();
      }
    });

    function shootArrow(){
      const shoulderX = archerX;
      const shoulderY = archerY - 20;
      const ARM_LENGTH = 30;
      const bowGripX_local = ARM_LENGTH;
      const STRING_OFFSET_X = 5;
      const stringPlaneX_local = bowGripX_local - STRING_OFFSET_X;

      const angle = Math.atan2(mouseY - shoulderY, mouseX - shoulderX);
      
      const handOnBowX_global = shoulderX + bowGripX_local * Math.cos(angle);
      const handOnBowY_global = shoulderY + bowGripX_local * Math.sin(angle);

      const dx = mouseX - handOnBowX_global;
      const dy = mouseY - handOnBowY_global;
      const dist = Math.min(maxPullDistance, Math.hypot(dx, dy));
      
      const nockPointX_global = shoulderX + (stringPlaneX_local - dist) * Math.cos(angle);
      const nockPointY_global = shoulderY + (stringPlaneX_local - dist) * Math.sin(angle);

      let speed = 15;
      arrow = {
        x: nockPointX_global,
        y: nockPointY_global,
        vx: speed * Math.cos(angle),
        vy: speed * Math.sin(angle),
        angle: angle,
        pull: dist
      };
    }

    function spawnEnemy() {
      const enemyRadius = 20;
      const minDistanceFromArcher = 300;

      const minX = archerX + minDistanceFromArcher;
      const maxX = WIDTH - enemyRadius;
      const spawnableWidth = maxX - minX;
      const enemyX = Math.random() * spawnableWidth + minX;

      const minY = 50;
      const maxY = HEIGHT - 100;
      const spawnableHeight = maxY - minY;
      const enemyY = Math.random() * spawnableHeight + minY;

      enemy = {x: enemyX, y: enemyY, radius: enemyRadius};
    }

    function updateInfo(){
      info.textContent = `時間: ${timeLeft} 秒 ｜ 分數: ${score}`;
    }

    function gameLoop(){
      ctx.clearRect(0, 0, WIDTH, HEIGHT);

      drawArcher();

      if(enemy){
        drawEnemy(enemy.x, enemy.y);
      }

      if(arrow){
        arrow.vy += gravity * 0.1;
        arrow.x += arrow.vx;
        arrow.y += arrow.vy;
        arrow.angle = Math.atan2(arrow.vy, arrow.vx);

        drawArrow(arrow.x, arrow.y, arrow.angle, arrow.pull);

        if(enemy && distance(arrow.x, arrow.y, enemy.x, enemy.y) < enemy.radius){
          score++;
          arrow = null;
          spawnEnemy();
          updateInfo();
        }

        if(arrow && (arrow.x < 0 || arrow.x > WIDTH || arrow.y > HEIGHT)){
          arrow = null;
        }
      } 

      if(gameRunning && !arrow){
        drawAimingAssist();
      }

      if(gameRunning){
        requestAnimationFrame(gameLoop);
      }
    }
    
    function drawAimingAssist(){
        const shoulderX = archerX;
        const shoulderY = archerY - 20;
        const ARM_LENGTH = 30;
        const bowGripX_local = ARM_LENGTH;
        const STRING_OFFSET_X = 5;
        const stringPlaneX_local = bowGripX_local - STRING_OFFSET_X;

        const angle = Math.atan2(mouseY - shoulderY, mouseX - shoulderX);

        const handOnBowX_global = shoulderX + bowGripX_local * Math.cos(angle);
        const handOnBowY_global = shoulderY + bowGripX_local * Math.sin(angle);

        const dx = mouseX - handOnBowX_global;
        const dy = mouseY - handOnBowY_global;
        const dist = Math.min(maxPullDistance, Math.hypot(dx, dy));

        const nockPointX_global = shoulderX + (stringPlaneX_local - dist) * Math.cos(angle);
        const nockPointY_global = shoulderY + (stringPlaneX_local - dist) * Math.sin(angle);

        drawArrow(nockPointX_global, nockPointY_global, angle, dist);
    }

    function drawArcher() {
        const archerColor = '#333333';
        const bowColor = '#8B4513';
        const shoulderX = archerX;
        const shoulderY = archerY - 20;
        const ARM_LENGTH = 30;

        // --- Static Body ---
        ctx.save();
        ctx.strokeStyle = archerColor;
        ctx.fillStyle = archerColor;
        ctx.lineWidth = 10;
        ctx.lineCap = 'round';
        ctx.lineJoin = 'round';

        // Torso
        ctx.beginPath();
        ctx.moveTo(archerX, archerY - 25);
        ctx.lineTo(archerX, archerY + 15);
        ctx.stroke();

        // Head
        ctx.beginPath();
        ctx.arc(archerX, archerY - 40, 15, 0, Math.PI * 2);
        ctx.fill();

        // Legs
        ctx.beginPath();
        ctx.moveTo(archerX, archerY + 15);
        ctx.lineTo(archerX - 15, archerY + 60);
        ctx.moveTo(archerX, archerY + 15);
        ctx.lineTo(archerX + 15, archerY + 60);
        ctx.stroke();
        ctx.restore();

        // --- Calculations ---
        const angle = Math.atan2(mouseY - shoulderY, mouseX - shoulderX);
        const bowGripGlobalX = shoulderX + ARM_LENGTH * Math.cos(angle);
        const bowGripGlobalY = shoulderY + ARM_LENGTH * Math.sin(angle);
        const dx = mouseX - bowGripGlobalX;
        const dy = mouseY - bowGripGlobalY;
        const dist = Math.min(maxPullDistance, Math.hypot(dx, dy));
        const pullX = bowGripGlobalX - dist * Math.cos(angle);
        const pullY = bowGripGlobalY - dist * Math.sin(angle);

        // --- Right Arm ---
        ctx.save();
        ctx.strokeStyle = archerColor;
        ctx.lineWidth = 10;
        ctx.lineCap = 'round';
        ctx.beginPath();
        ctx.moveTo(archerX + 5, shoulderY); // Right shoulder
        ctx.lineTo(pullX, pullY);
        ctx.stroke();
        ctx.restore();

        // --- Rotated Left Arm/Bow Assembly ---
        ctx.save();
        ctx.translate(shoulderX, shoulderY);
        ctx.rotate(angle);

        const bowGripX = ARM_LENGTH;
        const handY = 0;
        const bowTipY = 60;
        const handX = bowGripX + 20;

        // Arm connects shoulder to the new hand position
        ctx.strokeStyle = archerColor;
        ctx.lineWidth = 10;
        ctx.beginPath();
        ctx.moveTo(0, 0);
        ctx.lineTo(handX, 0);
        ctx.stroke();

        const STRING_OFFSET_X = 5;
        const stringPlaneX = bowGripX - STRING_OFFSET_X;

        // Draw Bowstring (Pulled)
        ctx.strokeStyle = '#FFFFFF';
        ctx.lineWidth = 2;
        ctx.beginPath();
        ctx.moveTo(stringPlaneX, -bowTipY);
        ctx.lineTo(stringPlaneX - dist, 0);
        ctx.lineTo(stringPlaneX, bowTipY);
        ctx.stroke();

        // Draw Bow
        const bowCurve = 40;
        ctx.strokeStyle = bowColor;
        ctx.lineWidth = 8;
        ctx.beginPath();
        ctx.moveTo(bowGripX, -bowTipY);
        ctx.quadraticCurveTo(bowGripX + bowCurve, 0, bowGripX, bowTipY);
        ctx.stroke();

        // Draw Hand
        ctx.fillStyle = archerColor;
        ctx.beginPath();
        ctx.arc(handX, handY, 7, 0, Math.PI * 2);
        ctx.fill();

        ctx.restore();
    }

    function drawArrow(x, y, angle, pullDist = 0) {
        ctx.save();
        ctx.translate(x, y);
        ctx.rotate(angle);

        // Fixed length, longer than max pull distance (70)
        const ARROW_LENGTH = 120;

        // Arrow Shaft
        ctx.strokeStyle = '#8B4513';
        ctx.lineWidth = 4;
        ctx.lineCap = 'round';
        ctx.beginPath();
        ctx.moveTo(0, 0);
        ctx.lineTo(ARROW_LENGTH, 0);
        ctx.stroke();

        // Fletching
        ctx.strokeStyle = '#FFFFFF';
        ctx.lineWidth = 2; // Thinner

        // Feather 1
        ctx.beginPath();
        ctx.moveTo(25, -3);
        ctx.lineTo(20, 0);
        ctx.lineTo(25, 3);
        ctx.stroke();

        // Feather 2
        ctx.beginPath();
        ctx.moveTo(18, -3);
        ctx.lineTo(13, 0);
        ctx.lineTo(18, 3);
        ctx.stroke();
        
        // Feather 3
        ctx.beginPath();
        ctx.moveTo(11, -3);
        ctx.lineTo(6, 0);
        ctx.lineTo(11, 3);
        ctx.stroke();

        // Arrowhead
        ctx.fillStyle = '#333333';
        ctx.beginPath();
        ctx.moveTo(ARROW_LENGTH + 5, 0);
        ctx.lineTo(ARROW_LENGTH - 10, 7);
        ctx.lineTo(ARROW_LENGTH - 10, -7);
        ctx.closePath();
        ctx.fill();

        ctx.restore();
    }

    function drawEnemy(x, y){
      ctx.fillStyle = 'red';
      ctx.beginPath();
      ctx.arc(x, y, enemy.radius, 0, Math.PI * 2);
      ctx.fill();

      ctx.fillStyle = 'white';
      ctx.beginPath();
      ctx.arc(x - 7, y - 5, 5, 0, Math.PI * 2);
      ctx.arc(x + 7, y - 5, 5, 0, Math.PI * 2);
      ctx.fill();

      ctx.fillStyle = 'black';
      ctx.beginPath();
      ctx.arc(x - 7, y - 5, 2, 0, Math.PI * 2);
      ctx.arc(x + 7, y - 5, 2, 0, Math.PI * 2);
      ctx.fill();

      ctx.strokeStyle = 'black';
      ctx.lineWidth = 2;
      ctx.beginPath();
      ctx.moveTo(x - 10, y + 10);
      ctx.lineTo(x + 10, y + 10);
      ctx.stroke();
    }

    function distance(x1, y1, x2, y2){
      return Math.sqrt((x2 - x1)**2 + (y2 - y1)**2);
    }

    function startGame(){
      score = 0;
      timeLeft = 60;
      gameRunning = true;
      arrow = null;
      spawnEnemy();
      updateInfo();
      startBtn.style.display = 'none';
      restartBtn.style.display = 'none';

      timerId = setInterval(() => {
        timeLeft--;
        updateInfo();
        if(timeLeft <= 0){
          endGame();
        }
      }, 1000);

      gameLoop();
    }

    function endGame(){
      gameRunning = false;
      clearInterval(timerId);
      arrow = null;
      enemy = null;
      updateInfo();
      alert(`遊戲結束！你的分數是：${score}`);
      restartBtn.style.display = 'inline-block';
    }

    startBtn.addEventListener('click', startGame);
    restartBtn.addEventListener('click', () => {
      restartBtn.style.display = 'none';
      startGame();
    });
  </script>
</body>
</html>